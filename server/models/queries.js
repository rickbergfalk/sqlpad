const Joi = require('@hapi/joi');

/*
"chartConfiguration": {
    "chartType": "line",
    "fields": {
        "x": "created_month",
        "y": "package_count",
        "split": "keyword",
        "xFacet": "",
        "yFacet": "keyword",
        "trendline": "true"
    }
}
*/

const schema = Joi.object({
  _id: Joi.string().optional(), // generated by nedb
  name: Joi.string().required(),
  tags: Joi.array()
    .items(Joi.string().empty(''))
    .sparse()
    .optional(),
  connectionId: Joi.string()
    .optional()
    .empty(''),
  queryText: Joi.string()
    .optional()
    .empty(''),
  chartConfiguration: Joi.object({
    chartType: Joi.string()
      .optional()
      .empty(''),
    // key value pairings. key=chart property, value=field mapped to property
    fields: Joi.object()
      .unknown(true)
      .optional()
  }).optional(),
  // createdBy is EMAIL of user
  createdBy: Joi.string().required(),
  // updatedBy is EMAIL of user
  updatedBy: Joi.string().optional(),
  lastAccessedAt: Joi.date().default(Date.now)
});

class Queries {
  /**
   * @param {*} nedb
   * @param {*} sequelizeDb
   * @param {import('../lib/config')} config
   */
  constructor(nedb, sequelizeDb, config) {
    this.nedb = nedb;
    this.sequelizeDb = sequelizeDb;
    this.config = config;
  }

  findOneById(id) {
    return this.nedb.queries.findOne({ _id: id });
  }

  findAll() {
    return this.nedb.queries.find({});
  }

  removeById(id) {
    return this.nedb.queries.remove({ _id: id });
  }

  /**
   * Save query object
   * returns saved query object
   * @param {object} query
   */
  async save(query) {
    query.lastAccessedAt = new Date();

    // clean tags if present
    // sqlpad v1 saved a lot of bad inputs
    if (Array.isArray(query.tags)) {
      query.tags = query.tags
        .filter(tag => {
          return typeof tag === 'string' && tag.trim() !== '';
        })
        .map(tag => {
          return tag.trim();
        });
    }
    const joiResult = schema.validate(query);
    if (joiResult.error) {
      return Promise.reject(joiResult.error);
    }
    if (query._id) {
      await this.nedb.queries.update({ _id: query._id }, joiResult.value, {
        upsert: true
      });
      return this.findOneById(query._id);
    }
    const newQuery = await this.nedb.queries.insert(joiResult.value);
    return newQuery;
  }
}

module.exports = Queries;
